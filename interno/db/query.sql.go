// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package db

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const atualizarImagemProduto = `-- name: AtualizarImagemProduto :exec
UPDATE "produtos"
SET "imagem" = 'https://firebasestorage.googleapis.com/v0/b/sos-do-maceneiro.appspot.com/o/produtos%2F' || "id" || '.webp?alt=media'
WHERE "id" = $1
`

func (q *Queries) AtualizarImagemProduto(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, atualizarImagemProduto, id)
	return err
}

const atualizarProduto = `-- name: AtualizarProduto :exec
UPDATE "produtos"
SET "nome" = $1,
    "descricao" = $2,
    "preco" = $3,
    "unidade_medida" = $4,
    "quantidade_pacote" = $5,
    "peso" = $6,
    "ativo" = $7,
    "updated_at" = CURRENT_TIMESTAMP
WHERE "id" = $8
`

type AtualizarProdutoParams struct {
	Nome             string
	Descricao        string
	Preco            pgtype.Numeric
	UnidadeMedida    TipoUnidadeMedida
	QuantidadePacote int32
	Peso             pgtype.Numeric
	Ativo            bool
	ID               uuid.UUID
}

func (q *Queries) AtualizarProduto(ctx context.Context, arg AtualizarProdutoParams) error {
	_, err := q.db.Exec(ctx, atualizarProduto,
		arg.Nome,
		arg.Descricao,
		arg.Preco,
		arg.UnidadeMedida,
		arg.QuantidadePacote,
		arg.Peso,
		arg.Ativo,
		arg.ID,
	)
	return err
}

const criarCategoria = `-- name: CriarCategoria :one
INSERT INTO "categorias" ("nome", "imagem")
VALUES ($1, $2)
RETURNING "id"
`

type CriarCategoriaParams struct {
	Nome   string
	Imagem string
}

func (q *Queries) CriarCategoria(ctx context.Context, arg CriarCategoriaParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, criarCategoria, arg.Nome, arg.Imagem)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const criarProduto = `-- name: CriarProduto :one
INSERT INTO "produtos" (
        "nome",
        "descricao",
        "preco",
        "unidade_medida",
        "quantidade_pacote",
        "peso",
        "ativo",
        "ordem",
        "imagem"
    )
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, '')
RETURNING "id"
`

type CriarProdutoParams struct {
	Nome             string
	Descricao        string
	Preco            pgtype.Numeric
	UnidadeMedida    TipoUnidadeMedida
	QuantidadePacote int32
	Peso             pgtype.Numeric
	Ativo            bool
	Ordem            int32
}

func (q *Queries) CriarProduto(ctx context.Context, arg CriarProdutoParams) (uuid.UUID, error) {
	row := q.db.QueryRow(ctx, criarProduto,
		arg.Nome,
		arg.Descricao,
		arg.Preco,
		arg.UnidadeMedida,
		arg.QuantidadePacote,
		arg.Peso,
		arg.Ativo,
		arg.Ordem,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const criarUsuario = `-- name: CriarUsuario :one
INSERT INTO usuarios (
        nome,
        email,
        telefone,
        ativo
    )
VALUES (
        $1,
        $2,
        $3,
        $4
    )
RETURNING id, email, nome, telefone, role, ativo, created_at, updated_at
`

type CriarUsuarioParams struct {
	Nome     string
	Email    string
	Telefone string
	Ativo    bool
}

func (q *Queries) CriarUsuario(ctx context.Context, arg CriarUsuarioParams) (Usuario, error) {
	row := q.db.QueryRow(ctx, criarUsuario,
		arg.Nome,
		arg.Email,
		arg.Telefone,
		arg.Ativo,
	)
	var i Usuario
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Nome,
		&i.Telefone,
		&i.Role,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const pegarCategoriasProduto = `-- name: PegarCategoriasProduto :many
SELECT c.id, c.nome, c.imagem, c.created_at, c.updated_at
FROM "categorias" c
    JOIN "_CategoriaToProduto" cp ON c."id" = cp."A"
WHERE cp."B" = $1
`

func (q *Queries) PegarCategoriasProduto(ctx context.Context, b uuid.UUID) ([]Categoria, error) {
	rows, err := q.db.Query(ctx, pegarCategoriasProduto, b)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Categoria
	for rows.Next() {
		var i Categoria
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Imagem,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pegarProdutoUnico = `-- name: PegarProdutoUnico :one
SELECT p.id AS produto_id,
    p.nome AS produto_nome,
    p.descricao AS produto_descricao,
    p.preco AS produto_preco,
    p.unidade_medida AS produto_unidade_medida,
    p.quantidade_pacote AS produto_quantidade_pacote,
    p.peso AS produto_peso,
    p.ativo AS produto_ativo,
    p.ordem AS produto_ordem,
    p.imagem AS produto_imagem,
    array_to_string(array_agg(c.nome), ',') AS categorias_relacionadas
FROM produtos AS p
    JOIN "_CategoriaToProduto" AS cp ON p.id = cp."B"
    JOIN categorias AS c ON cp."A" = c.id
WHERE p.id = $1
GROUP BY p.id,
    p.nome,
    p.descricao,
    p.preco,
    p.unidade_medida,
    p.quantidade_pacote,
    p.peso,
    p.ativo,
    p.ordem,
    p.imagem
`

type PegarProdutoUnicoRow struct {
	ProdutoID               uuid.UUID
	ProdutoNome             string
	ProdutoDescricao        string
	ProdutoPreco            pgtype.Numeric
	ProdutoUnidadeMedida    TipoUnidadeMedida
	ProdutoQuantidadePacote int32
	ProdutoPeso             pgtype.Numeric
	ProdutoAtivo            bool
	ProdutoOrdem            int32
	ProdutoImagem           string
	CategoriasRelacionadas  string
}

func (q *Queries) PegarProdutoUnico(ctx context.Context, id uuid.UUID) (PegarProdutoUnicoRow, error) {
	row := q.db.QueryRow(ctx, pegarProdutoUnico, id)
	var i PegarProdutoUnicoRow
	err := row.Scan(
		&i.ProdutoID,
		&i.ProdutoNome,
		&i.ProdutoDescricao,
		&i.ProdutoPreco,
		&i.ProdutoUnidadeMedida,
		&i.ProdutoQuantidadePacote,
		&i.ProdutoPeso,
		&i.ProdutoAtivo,
		&i.ProdutoOrdem,
		&i.ProdutoImagem,
		&i.CategoriasRelacionadas,
	)
	return i, err
}

const pegarTodasCategorias = `-- name: PegarTodasCategorias :many
SELECT id, nome, imagem, created_at, updated_at
FROM "categorias"
ORDER BY "updated_at" DESC
LIMIT $1 OFFSET $2
`

type PegarTodasCategoriasParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) PegarTodasCategorias(ctx context.Context, arg PegarTodasCategoriasParams) ([]Categoria, error) {
	rows, err := q.db.Query(ctx, pegarTodasCategorias, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Categoria
	for rows.Next() {
		var i Categoria
		if err := rows.Scan(
			&i.ID,
			&i.Nome,
			&i.Imagem,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pegarTodosProdutos = `-- name: PegarTodosProdutos :many
SELECT p.id AS produto_id,
    p.nome AS produto_nome,
    p.descricao AS produto_descricao,
    p.preco,
    p.unidade_medida,
    p.quantidade_pacote,
    p.peso,
    p.ativo AS produto_ativo,
    p.ordem,
    p.imagem AS produto_imagem,
    array_to_string(array_agg(c.nome), ',') AS categorias
FROM produtos p
    LEFT JOIN "_CategoriaToProduto" cp ON p.id = cp."B"
    LEFT JOIN categorias c ON cp."A" = c.id
GROUP BY p.id,
    p.nome,
    p.descricao,
    p.preco,
    p.unidade_medida,
    p.quantidade_pacote,
    p.peso,
    p.ativo,
    p.ordem,
    p.imagem
ORDER BY p.updated_at DESC
LIMIT $1 OFFSET $2
`

type PegarTodosProdutosParams struct {
	Limit  int32
	Offset int32
}

type PegarTodosProdutosRow struct {
	ProdutoID        uuid.UUID
	ProdutoNome      string
	ProdutoDescricao string
	Preco            pgtype.Numeric
	UnidadeMedida    TipoUnidadeMedida
	QuantidadePacote int32
	Peso             pgtype.Numeric
	ProdutoAtivo     bool
	Ordem            int32
	ProdutoImagem    string
	Categorias       string
}

func (q *Queries) PegarTodosProdutos(ctx context.Context, arg PegarTodosProdutosParams) ([]PegarTodosProdutosRow, error) {
	rows, err := q.db.Query(ctx, pegarTodosProdutos, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PegarTodosProdutosRow
	for rows.Next() {
		var i PegarTodosProdutosRow
		if err := rows.Scan(
			&i.ProdutoID,
			&i.ProdutoNome,
			&i.ProdutoDescricao,
			&i.Preco,
			&i.UnidadeMedida,
			&i.QuantidadePacote,
			&i.Peso,
			&i.ProdutoAtivo,
			&i.Ordem,
			&i.ProdutoImagem,
			&i.Categorias,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const pegarUsuarioEmail = `-- name: PegarUsuarioEmail :one
SELECT id, email, nome, telefone, role, ativo, created_at, updated_at
FROM usuarios
WHERE email = $1
LIMIT 1
`

func (q *Queries) PegarUsuarioEmail(ctx context.Context, email string) (Usuario, error) {
	row := q.db.QueryRow(ctx, pegarUsuarioEmail, email)
	var i Usuario
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.Nome,
		&i.Telefone,
		&i.Role,
		&i.Ativo,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
